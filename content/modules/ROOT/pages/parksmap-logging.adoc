= ロギング
:navtitle: ロギング

include::vars.adoc[]

OpenShift は、アプリケーションログを表示するための便利なメカニズムをいくつか提供しています。
まず第一に、Web コンソールまたはコマンドラインから *Pod* のログを直接確認できる機能です。

[#container_logs]
== 背景: コンテナログ

OpenShift は、コンテナがすべての情報を `STDOUT` にログ出力することを想定しています。これにより、通常の情報とエラー情報の両方が標準化されたメカニズムによって取得されます。*Pod* のログを直接確認する場合、基本的にはコンテナランタイムを経由して、OpenShift の API を介してコンテナのログにアクセスすることになります。

[NOTE]
====
アプリケーションによっては、すべての情報を `STDOUT` と `STDERR` に送信するように設計されていない場合があります。多くの場合、複数のローカルログファイルが使用されます。 OpenShift はこれらのファイルから情報を解析することはできませんが、作成を阻止することはできません。場合によっては、ログ情報は外部システムに送信されます。OpenShift はこれらの動作を禁止していません。既にログ情報を外部システムに送信しているため、またはログ情報をさまざまなファイルに書き込んでいるために、`STDOUT` にログを記録しないアプリケーションがある場合でも、心配する必要はありません。OpenShift は引き続き動作します。
====

[#examining_logs]
== 演習: ログの確認

アプリケーションはすでにデプロイされているので、ログを確認できます。
*Topology*  viewで `parksmap` エントリをクリックし、*Resources* タブをクリックします。*Pod* エントリの横に *View Logs* リンクが表示されます。

[.bordershadow]
image::parksmap-view-logs-link.png[link="self",window=_blank]

*Pod* のログを表示するには、*View Logs* リンクをクリックします。


[.bordershadow]
image::parksmap-logging-console-logs.png[link="self",window=_blank]

WARNING: ログにエラーが見つかったとしても大丈夫です。すぐに修正できます。

コマンドラインからログを表示することもできます。`oc logs` コマンドを使用し、ラベルセレクターを渡すと、セレクターに一致するすべてのPodのログが表示されます。

[source,role="copypaste"]
----
oc logs -l app=parksmap
----

アプリケーション ログが表示されます。

[.console-output]
[source]
----
2019-05-22 19:37:01.433  INFO 1 --- [           main] o.s.m.s.b.SimpleBrokerMessageHandler     : Started.
2019-05-22 19:37:01.465  INFO 1 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2019-05-22 19:37:01.468  INFO 1 --- [           main] c.o.evg.roadshow.ParksMapApplication     : Started ParksMapApplication in 3.97 seconds (JVM running
 for 4.418)
2019-05-22 19:38:00.762  INFO 1 --- [MessageBroker-1] o.s.w.s.c.WebSocketMessageBrokerStats    : WebSocketSession[0 current WS(0)-HttpStream(0)-HttpPoll(
0), 0 total, 0 closed abnormally (0 connect failure, 0 send limit, 0 transport error)], stompSubProtocol[processed CONNECT(0)-CONNECTED(0)-DISCONNECT(0)]
, stompBrokerRelay[null], inboundChannel[pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0], outboundChannel[pool size = 0, active
 threads = 0, queued tasks = 0, completed tasks = 0], sockJsScheduler[pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]
2019-05-22 19:44:11.517  INFO 1 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-05-22 19:44:11.517  INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization sta
rted
2019-05-22 19:44:11.533  INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization com
pleted in 16 ms
2019-05-22 19:44:13.395  INFO 1 --- [nio-8080-exec-2] c.o.e.roadshow.rest.BackendsController   : Backends: getAll
----

WARNING: ログをスクロールしていくと、service accountに関するエラーに気付くかもしれません。これは何でしょうか？ご安心ください。すぐに説明いたします。
