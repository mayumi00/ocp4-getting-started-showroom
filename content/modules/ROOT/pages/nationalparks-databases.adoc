= データベースへの接続
:navtitle: データベースへの接続

include::vars.adoc[]

このセクションでは、`nationalparks` アプリケーションが位置情報を保存するために使用する MongoDB データベースをデプロイして接続します。

最後に、`nationalparks` アプリケーションをマップ可視化ツールのバックエンドとして設定します。これにより、OpenShift のディスカバリ（discovery）メカニズムを使用して `parksmap` コンポーネントがアプリケーションを動的に検出し、マップデータが自動的に表示されるようになります。

[.bordershadow]
image::roadshow-app-architecture-nationalparks-2.png[link="self",window=_blank]

[#storage]
== 背景：ストレージ

最も有用なアプリケーションは、何らかの形で「ステートフル」または「ダイナミック」であり、これは通常、データベースやその他の形式のデータストレージによって実現されます。このワークショップセクションでは、
アプリケーションアーキテクチャにMongoDBを追加し、`nationalparks`デプロイメントを設定してデータベースに接続します。
接続パラメータは、link:https://kubernetes.io/docs/concepts/configuration/secret/[Secret, window="_blank"]を使用した環境変数を使用してデプロイメントに提供されます。


[#create_mongodb_instance]
== 演習: MongoDB のデプロイ

最初のステップは、データベース接続の認証情報などの機密情報を保存するために使用する *Secret* を作成することです。
*Workloads* → *Secrets* で、右上の *Create* ボタンをクリックし、*From YAML* を選択します。


[.bordershadow]
image::mongodb_create_secret.png[link="self",window=_blank]

エディターで次の YAML を貼り付けます。

[source,role="copypaste",subs="attributes"]
----
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-credentials
  namespace: {ocp4_starter_project}
type: Opaque
stringData:
  admin-usr: admin
  admin-pwd: secret
  app-usr: parksapp
  app-pwd: keepsafe
----

[.bordershadow]
image::mongodb_create_secret_dialog.png[link="self",window=_blank]

フォーム下部の *Create* ボタンをクリックします。

Secretを入力したら、他のアプリケーションを追加した時と同じように、右上の *+* アイコンをクリックします。*Container images* オプションを選択します。以下の情報を入力します。


* Image section:
    - Image name from external registry → `mongo:6.0.4`
    - Runtime icon → choose `mongodb`

* General section:
    - Application → `workshop`
    - Name → `mongodb`

[.bordershadow]
image::mongodb_deploy_image_image.png[link="self",window=_blank]

* リソース タイプのドロップダウンが *Deployment* オプションに設定されていることを確認します。

* *Show advanced Deployment options* をクリックします。
    - ここで、以前に作成した `mongodb-credentials` という名前のシークレットから取得される次の 2 つの環境変数を追加します。
    - *+Add from ConfigMap or Secret* をクリックし、名前として `MONGO_INITDB_ROOT_USERNAME` と入力します。
    - 値には、リソースとして `mongodb-credentials` 、キーとして `admin-usr` を選択します。
    - 再度、*+Add from ConfigMap or Secret* をクリックし、名前として `MONGO_INITDB_ROOT_PASSWORD` と入力します。
    - 値には、リソースとして `MONGO_INITDB_ROOT_PASSWORD` 、キーとして `admin-pwd` を選択します。

* Advanced options:
    - Create a route → OpenShift クラスター外部のクライアントはデータベースにアクセスしないため、*チェックを外します*。

[.bordershadow]
image::mongodb_deploy_image_general.png[link="self",window=_blank]

最後に、ページ下部の *Create* ボタンをクリックして、MongoDBコンテナをデプロイします。

次のステップでは、このMongoDBインスタンスに、nationalparksアプリケーションが接続を確立するために使用する特定のユーザーを作成します。そのためには、Topology viewで *MongoDB Deployment* をクリックし、右側のビューペインに表示される対応する *Pod* をクリックします。

[.bordershadow]
image::mongodb_deployment_topology_pod.png[link="self",window=_blank]


最終的にPodのdetailsビューが表示され、*Terminal* をクリックして、基礎となるコンテナでターミナル セッションを開始できます。

[.bordershadow]
image::mongodb_pod_details_terminal.png[link="self",window=_blank]

適切な設定とロールを持つデータベース ユーザーを作成するには、次のスニペットをコピーしてターミナル ウィンドウに貼り付けます。

[source,role=copypaste]
----
mongosh -u admin -p secret --authenticationDatabase admin --eval 'use parksapp' --eval 'db.createUser({user: "parksapp", pwd: "keepsafe", roles: [{ role: "dbAdmin", db: "parksapp" },{ role: "readWrite", db: "parksapp" }]})' --quiet
----

NOTE: 商用環境では、コンテナのエントリポイントを変更したり、https://kubernetes.io/docs/concepts/workloads/pods/init-containers/[init container, window="_blank"] を使用してデータベース構成を管理したりできます。

コマンドが成功すると、以下の出力が表示されます。

[.console-output]
[source]
----
{ ok: 1 }
----
これでデータベースに関する準備はすべて完了です。nationalparksアプリケーションに焦点を戻してください。*Topology* viewに戻り、*nationalparks Deployment* をクリックして、右側のビューペインのドロップダウンから _Actions → Edit Deployment_ を選択してください。

[.bordershadow]
image::nationalparks_deployment_edit.png[link="self",window=_blank]

*Edit Deployment* ダイアログで、*Environment Variables*セクションまでスクロールダウンし、以下の4つのエントリを追加します。まず、サーバーホストとデータベースを設定します。

    - `MONGODB_SERVER_HOST`: `mongodb`
    - `MONGODB_DATABASE`: `parksapp`

`mongodb` の `MONGODB_SERVER_HOST` 値は、MongoDB コンテナイメージをデプロイしたときに作成された MongoDB *Service* に解決されます。

他の 2 つの認証情報は、`mongodb-credentials` Secretから取得されます。

*+Add from ConfigMap or Secret* をクリックし、名前に `MONGODB_USER` と入力します。値には、リソースとして `mongodb-credentials`、キーとして `app-usr` を選択します。

再度、*+Add from ConfigMap or Secret* をクリックし、名前に `MONGODB_PASSWORD` と入力します。値には、リソースとして `mongodb-credentials`、キーとして `app-pwd` を選択します。

[.bordershadow]
image::nationalparks_deployment_env_vars_secrets.png[link="self",window=_blank]

最後に、ダイアログ下部の *Save* ボタンをクリックします。これにより、アプリケーションの新しいバージョンのロールアウトが開始され、先ほどデプロイしたMongoDBインスタンスに接続されます。


[NOTE]
====
データベース接続が魔法のように機能し始めたのはなぜだろうと、不思議に思われるかもしれません。
OpenShift にアプリケーションをデプロイする際は、Secret または ConfigMap を使用して環境変数を作成し、依存システムへの接続パラメータを定義するのが最適です。これにより、ソースコードを変更することなく、異なる環境間でのアプリケーションの移植が可能になります。接続を実行し、データベーススキーマを作成するソースファイルは、
こちらでご覧いただけます。

[source,role="copypaste",subs="attributes"]
----
{ocp4_starter_openshift_roadshow}/nationalparks/blob/master/src/main/java/com/openshift/evg/roadshow/parks/db/MongoDBConnection.java#L44-l48
----

データベース接続が定義されていない場合、アプリケーションが例外をキャッチすることに注意してください。これが、クラッシュせずにデプロイできた理由です。

====

[#adding_labels]
== 演習: ラベルの追加

次に、MongoDB デプロイメントに割り当てられたラベルを修正しましょう。*Topology* viewで MongoDB デプロイメントを選択し、_Actions → Edit Labels_ を選択します。

== Exercise: Adding Labels

[.bordershadow]
image::mongodb_deployment_labels.png[link="self",window=_blank]

前回と同様に、3つのラベルを追加します。

アプリケーショングループの名前:

[source,role=copypaste]
----
app=workshop
----

次にこのデプロイメントの名前:

[source,role=copypaste]
----
component=nationalparks
----

そして最後に、このコンポーネントがアプリケーション全体で果たす役割:

[source,role=copypaste]
----
role=database
----

[#exploring_openshift_magic]
== 演習: OpenShift の魔法を探る

データベース接続環境変数を使用して `nationalparks` デプロイメントを更新すると、
魔法のようなことが起こりました。OpenShift は *ReplicaSet* を更新することで、新しい変数を使用するアプリケーションの新しいバージョンをロールアウトしました。
`oc get rs -l app=nationalparks` の出力を確認することで、これを確認できます。


[.console-output]
[source]
----
NAME                       DESIRED   CURRENT   READY   AGE
nationalparks-58bd4758fc   0         0         0       4m58s
nationalparks-7445576cd9   0         0         0       6m42s
nationalparks-789c6bc4f4   1         1         1       41s
----

以前のレプリカセットのインスタンス数（DESIRED）と現在のインスタンス数を確認できます。以前のインスタンスのDESIREDと現在のインスタンス数は0です。
これは、OpenShiftが以前のアプリケーションPodを新しい構成を使用する新しいPodに正常に置き換えたことを意味します。

[#data_data_everywhere]
== 演習: どこにでもデータあり

データベースがデプロイされたので、再び `nationalparks` ウェブサービスにアクセスして、
データをクエリできます。

[source,role="copypaste",subs="attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/data/all
----

そして結果は？

[.console-output]
[source]
----
[]
----

データはどこにあるのでしょうか？これまでのプロセスを思い出してみてください。アプリケーションをデプロイし、次にデータベースをデプロイしました。しかし、実際には何もデータがデータベースにロードされていません。

アプリケーションは、まさにそのためのエンドポイントを提供しています。Webブラウザで次のURLを開くと、`nationalparks`アプリケーションがサンプルデータセットをMongoDBに挿入します。

[source,role="copypaste",subs="attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/data/load
----

そして結果は？

[.console-output]
[source]
----
Items inserted in database: 2893
----

その後、`/ws/data/all` に戻ると、大量の JSON データが表示されます。

NOTE: Firefox 54 などのブラウザでは、出力された JSON が正しく解析されないため、エラーが発生する場合があります。これはブラウザの問題であり、アプリケーションは正常に動作しています。

[source,role="copypaste",subs="attributes"]
----
https://parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

There's just one thing. The main map *still* isn't displaying the parks.
That's because the frontend only tries to talk to services that have
the right *Label*.

ただ一つ問題があります。メインマップにはまだ公園が表示されていません。
これは、フロントエンドが適切な *Label* を持つサービスとのみ通信しようとしているためです。


[#working_with_labels]
== 演習: ラベルの操作

*Services*、*Routes*、*Selectors*について学習した際に、*Label*が単なるキーと値のペアであることを学びました。一般的に、*Label*は単なる任意のキーと値のペアです。例えば、次のようになります。

* `pizza=pepperoni`
* `pet=dog`
* `openshift=awesome`

parksmap の場合、アプリケーションは実際に OpenShift API にクエリを実行し、プロジェクト内の *Routes* と *Services* について問い合わせます。いずれかの *Label* が `type=parksmap-backend` である場合、アプリケーションはエンドポイントに接続してマップデータをクエリする必要があることを認識します。
これを実行するコードは link:{ocp4_starter_openshift_roadshow}/parksmap-web/blob/master/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[in theRouteWatcher.java file,window='_blank'] からご確認できます。

幸いなことに、コマンドラインにはラベルを操作する便利な方法が用意されています。
`nationalparks` routeを `describe` します。

[source,role=copypaste]
----
oc describe route nationalparks
----

[.console-output]
[source,subs="attributes"]
----
Name:                   nationalparks
Namespace:              {ocp4_starter_project}
Created:                2 hours ago
Labels:                 app=workshop
                        app.kubernetes.io/component=nationalparks
                        app.kubernetes.io/instance=nationalparks
                        app.kubernetes.io/name=java
                        app.kubernetes.io/part-of=workshop
                        app.openshift.io/runtime=java
                        app.openshift.io/runtime-version=11
                        component=nationalparks
                        role=backend  
Annotations:            openshift.io/host.generated=true                          
Requested Host:         nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}
                        exposed on router router 2 hours ago
Path:                   <none>
TLS Termination:        <none>
Insecure Policy:        <none>
Endpoint Port:          8080-tcp

Service:                nationalparks
Weight:                 100 (100%)
Endpoints:              10.1.9.8:8080
----

すでにラベルがいくつか付いているのが分かります。`oc label` を使って、RouteWatcher がバックエンドを検出するために必要なラベルを追加します。

[source,role=copypaste]
----
oc label route nationalparks type=parksmap-backend
----

次のような画面が表示されます。

[.console-output]
[source]
----
route.route.openshift.io/nationalparks labeled
----

parksmap URL にアクセスしてブラウザを確認してください。

[source,role="copypaste",subs="attributes"]
----
https://parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

[.bordershadow]
image::nationalparks-databases-new-parks.png[link="self",window=_blank]

公園が突然現れているのに気づくでしょう。本当にすごいですね！
