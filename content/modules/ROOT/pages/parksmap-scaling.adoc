= アプリのスケーリング
:navtitle: アプリのスケーリング

include::vars.adoc[]

[#deployments_and_replication_controllers]
== 背景: DeploymentとReplicaSets

*Service* は、作成・削除される可能性のある *Pod* のルーティングと負荷分散を提供します。一方、*ReplicaSets* (RS) と *ReplicationControllers* (RC) は、必要な数の *Pod* (レプリカ) の実行を指定し、確実に実行するために使用します。例えば、アプリケーションサーバーで常に 3 つの *Pod* (インスタンス) を実行したい場合は、*ReplicaSet* が必要です。RS がないと、強制終了または終了した *Pod* は自動的に再起動されません。*ReplicaSets* と *ReplicationControllers* は、OpenShift における自己修復機能を提供します。*Deployment* は *ReplicaSet* を制御し、*ReplicationControllers* は *DeploymentConfigs* によって制御されます。

link:{ocp4_starter_openshift_docs}/html/building_applications/deployments[deployments documentation,window='_blank']: より:

[quota]
__
レプリケーションコントローラーと同様に、ReplicaSet はネイティブ Kubernetes API オブジェクトであり、指定された数の Pod レプリカが常に実行されていることを保証します。レプリカセットとレプリケーションコントローラーの違いは、レプリカセットがセットベースのセレクター要件をサポートするのに対し、レプリケーションコントローラーは等価性ベースのセレクター要件のみをサポートすることです。
__

Kubernetes では、*Deployment* はデプロイ方法を定義します。ほとんどの場合、*Pod*、*Service*、*ReplicaSet*、*Deployment* の各リソースを組み合わせて使用​​します。OpenShift は、Web コンソールまたは CLI を使用してコンテナイメージをデプロイする際に、これらをすべて自動的に作成します。

*Deployment* や *Service* を使用せずに、いくつかの *Pod* と *ReplicaSet* が必要な高度なシナリオもあります。これらのケースにご興味がある場合は、ワークショップ終了後に講師にお問い合わせください。

[#exploring_deployment_related_objects]
== 演習: デプロイメント関連オブジェクトの探索

*ReplicaSet* と *Deployment* の背景を理解したので、これらがどのように連携するかを確認しましょう。 OpenShift に `parksmap` イメージをデプロイするように指示したときに作成された *Deployment* を確認します。

[source,role="copypaste"]
----
oc get deployment
----

[.console-output]
[source]
----
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
parksmap   1/1     1            1           20m
----

詳細を確認するには、*ReplicaSet* (RS) を確認します。

[source,role="copypaste"]
----
oc get rs
----

[.console-output]
[source]
----
NAME                  DESIRED   CURRENT   READY   AGE
parksmap-65c4f8b676   1         1         1       21m
----

この出力は、現在 1 つの *Pod* がデプロイされる予定であることを示しています。 （`Desired`）に設定されており、実際にデプロイされている *Pod* は 1 つ（`Current`）です。この必要数を変更することで、OpenShift に必要となる *Pod* の数を増減させることができます。

TIP: OpenShift の *Horizo​​ntalPodAutoscaler (HPA)* は、一連の Pod の CPU とメモリの使用状況をモニタリングし、インスタンスを追加することで RC を更新してアプリケーションの安定性を確保します。Horizo​​ntal Pod Autoscaler の詳細については、link:{ocp4_starter_openshift_docs}/html/nodes/working-with-pods#nodes-pods-autoscaling[Horizontal Pod Autoscalers in the documentation,window='_blank'] を参照してください。

[#scaling_the_application]
== 演習: アプリケーションのスケーリング

この演習では、parksmap アプリケーションを最大 2 つのインスタンスにスケーリングします。これは、`oc scale` コマンドを使用するか、OpenShift Web コンソールで Desired Count を増やすことで実行できます。どちらか適切な方法を選択してください。

[source,role="copypaste"]
----
oc scale --replicas=2 deployment/parksmap
----

または、*Developer Perspective* で最大 2 つのPodにスケールアップすることもできます。トポロジビューから、`parksmap` デプロイメント構成をクリックし、*Details* タブを選択します。

[.bordershadow]
image::parksmap-details.png[link="self",window=_blank]

次に、Podの可視化の横にある *^* アイコンをクリックして、最大 2 つのPodにスケールアップします。

[.bordershadow]
image::parksmap-scaleup.png[link="self",window=_blank]

レプリカ数の変更を確認するには、次のコマンドを実行します。

[source,role="copypaste"]
----
oc get rs
----

[.console-output]
[source]
----
NAME                  DESIRED   CURRENT   READY   AGE
parksmap-65c4f8b676   2         2         2       23m
----

レプリカが2つになったことがわかります。 `oc get pods` コマンドでPodの数を確認します。

[source,role="copypaste"]
----
oc get pods
----

[.console-output]
[source]
----
NAME READY STATUS RESTARTS AGE
parksmap-65c4f8b676-fxcrq 1/1 Running 0 92s
parksmap-65c4f8b676-k5gkk 1/1 Running 0 24m
----

最後に、*Service* が 2 つのエンドポイントを正確に反映していることを確認します。

[source,role="copypaste"]
----
oc describe svc parksmap
----

次のような出力が表示されます。*Service* が 2 つの *Endpoints* をターゲットにしていることに注意してください。

[.console-output]
[source]
----
Name:              parksmap
Namespace:         user1
Labels:            app=workshop
                   app.kubernetes.io/component=parksmap
                   app.kubernetes.io/instance=parksmap
                   app.kubernetes.io/part-of=workshop
                   component=parksmap
                   role=frontend
Annotations:       openshift.io/generated-by: OpenShiftWebConsole
Selector:          app=parksmap,deploymentconfig=parksmap
Type:              ClusterIP
IP:                172.30.22.209
Port:              8080-tcp  8080/TCP
TargetPort:        8080/TCP
Endpoints:         10.128.2.90:8080,10.131.0.40:8080
Session Affinity:  None
Events:            <none>
----

*Service* のエンドポイントを確認する別の方法は、次のとおりです。

[source,role="copypaste"]
----
oc get endpoints parksmap
----

次のような出力が表示されます。

[.console-output]
[source]
----
NAME       ENDPOINTS                           AGE
parksmap   10.128.2.90:8080,10.131.0.40:8080   45m
----

各 Pod は OpenShift 環境内で一意の IP アドレスを取得するため、IP アドレスは異なる可能性があります。エンドポイントリストを使用すると、サービスの背後にある Pod の数を素早く確認できます。

また、*Developer Perspective* では、両方の *Pod* が実行中であることを確認できます。

[.bordershadow]
image::parksmap-scaled.png[link="self",window=_blank]

全体的に見て、アプリケーションのスケーリングは極めてシンプルです。OpenShiftは既存のイメージの新しいインスタンスを起動するため、特に、新しいPodが https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/[スケジュールされた, window="_blank"]ノードにそのイメージが既にキャッシュされている場合、アプリケーションのスケーリングは非常に迅速に行われます。


[#application_self_healing]
== アプリケーションの「自己修復」

OpenShift の *RS* は、必要な数の *Pod* が稼働しているかどうかを常に監視しているため、必要なレプリカ数が現在の数と一致しない場合、OpenShift が状況を「修正」すると期待されるかもしれません。

現在 2 つの *Pod* が稼働しているので、1 つを「誤って」強制終了した場合に何が起こるかを確認できます。`oc get pods` コマンドを再度実行し、*Pod* 名を選択します。次に、以下の操作を行います。

[source,role="copypaste"]
----
oc delete pod parksmap-7dfd599cd7-vgc7z && oc get pods
----

[.console-output]
[source]
----
pod "parksmap-65c4f8b676-k5gkk" deleted
NAME                        READY   STATUS            RESTARTS     AGE
parksmap-65c4f8b676-bjz5g   1/1     ContainerCreating   0          9s
parksmap-65c4f8b676-fxcrq   1/1     Running             0          4m48s
----

何かお気づきでしょうか？コンテナが 1 つ削除されましたが、その代わりに新しいコンテナが既に作成されています。

さらに、OpenShift はアプリケーションインスタンスの稼働状態や準備状態をチェックするための基本的な機能を提供しています。基本的なチェックが不十分な場合は、コンテナ内でコマンドを実行してチェックを行うこともできます。このコマンドは、インストールされている任意の言語を使用したスクリプトにすることができます。

これらのヘルスチェックに基づいて、OpenShift は `parksmap` アプリケーションインスタンスが正常でないと判断した場合、そのインスタンスを削除し、代わりに新しいインスタンスを作成します。これにより、必要な数のレプリカが常に確保されます。

アプリケーションのプローブに関する詳細は、ドキュメントの
link:{ocp4_starter_openshift_docs}/html/building_applications/application-health[Application Health,window='_blank']
セクション、およびこのガイドの後半で説明されています。

[#scale_down]
== 演習: スケールダウン

先に進む前に、アプリケーションを単一インスタンスにスケールダウンしてください。

お好きな方法でスケールダウンしてください。

WARNING:  1 Pod にスケールダウンしないと、後のセクションで予期しない動作が発生します。これはアプリケーションのコーディング方法によるものであり、OpenShift とは関係ありません。
