= Nationalparks バックエンドアプリケーション
:navtitle: Nationalparks Backend App

include::vars.adoc[]

このセクションでは、ビジュアライザーアプリケーション（前のセクションでデプロイした `parksmap` Webコンポーネント）に2つの主要なRESTエンドポイントを公開するバックエンドサービスをデプロイします。
このアプリケーションは、MongoDBデータベースに保存されている各国立公園の情報（座標を含む）を照会します。また、このアプリケーションは外部アクセスポイントも提供し、エンドユーザーがAPIを直接使用できるようにします。

[.bordershadow]
image::roadshow-app-architecture-nationalparks-1.png[link="self",window=_blank]

[#source_to_image]
== 背景: Source-to-Image (S2I)

前回のセクションでは、既存のコンテナイメージをデプロイする方法を学びました。
今回は、OpenShift が既存の Git リポジトリ内のソースコードから直接コンテナイメージをビルドする方法を学びます。これは、Source-to-Image プロジェクトを使用して実現されます。

link:{ocp4_starter_openshift_github}/source-to-image[Source-to-Image (S2I),window='_blank']は、Red Hat がスポンサーとなっているオープンソースプロジェクトであり、次の目標を掲げています。

[quote]
--
Source-to-image (S2I) は、再現可能なコンテナイメージをビルドするためのツールです。S2I は、コンテナイメージにソースコードを挿入し、ビルダーイメージとビルド済みのソースを組み込んだ新しいコンテナイメージをアセンブルすることで、すぐに実行できるイメージを生成します。その結果は、docker run ですぐに使用できます。S2I は、以前にダウンロードした依存関係や以前にビルドされたアーティファクトなどを再利用するインクリメンタルビルドをサポートしています。
--

OpenShift は、Dockerfile 内の指示を使用したコンテナイメージのビルドや「カスタム」ビルドに加えて、ビルドメカニズムの 1 つとして S2I を使用できます。

OpenShift は、ビルドPodと呼ばれる特別な *Pod* 内で S2I プロセスを実行するため、ビルドはクォータ、制限、リソーススケジュールなど、OpenShift のその他の側面の影響を受けます。

S2Iの詳細な説明はこのワークショップの範囲を超えていますが、link:{ocp4_starter_openshift_docs}/html/images/creating-images[OpenShift S2I documentation,window='_blank']
またはlink:{ocp4_starter_openshift_github}/source-to-image[GitHub,window='_blank']で詳細情報を見つけることができます。S2Iについて覚えておくべき唯一の重要な概念は、それが魔法だということです。


[#creating_a_application]
== 演習: バックエンドアプリケーションの作成

この演習でデプロイするバックエンドサービスは、
`nationalparks` と呼ばれます。これは、MongoDB データベースに対して 2D 地理空間クエリを実行し、世界中のすべての国立公園の地図座標を検索して返すアプリケーションです。これは、場所の JSON リストを返す Web サービスをデプロイする、という言い方を少し変えただけです。


[#add_to_project]
=== プロジェクトへの追加
`nationalparks` コンポーネントは、既存のフロントエンド (parksmap) が使用するデータを提供するバックエンドであるため、これまで使用してきた既存のプロジェクト内にビルドしてデプロイします。

[#using_application_code_on_git_server]
=== Git サーバーでのアプリケーションコードの使用

OpenShift は、アクセス可能なあらゆる Git リポジトリと連携できます。GitHub、GitLab、その他 Git をサポートするサーバーであれば、どれでも利用可能です。Git サーバーに Webhook を登録すれば、アプリケーションコードの更新をトリガーとして OpenShift のビルドを開始することもできます。

セクションの後半では、コードを変更し、アプリケーションをリビルドします。それでは、バックエンドサービスのデプロイ方法を見ていきましょう。


[#deploying_the_backend_service]
=== バックエンドサービスのデプロイ

既存のイメージで *+* ボタンを使用したのと同様に、
ソースコードリポジトリを指定する場合にも同じ操作が可能です。
シンプルな link:{ocp4_starter_openshift_roadshow}/nationalparks.git[Java,window='_blank'] S2I イメージで使用してみましょう。

Topology viewで、ヘッダーの *+* ボタンをクリックし、*Import from Git* を選択します。


[.bordershadow]
image::nationalparks-show-add-options.png[link="self",window=_blank]

*Import from Git* ワークフローでは、いくつかの選択項目に基づいてアプリのデプロイプロセスをガイドします。

Git リポジトリの URL に以下を入力してください。

[source,role=copypaste,subs="attributes"]
----
{ocp4_starter_openshift_roadshow}/nationalparks.git
----

OpenShift はソースコードで使用されているプログラミング言語を自動的に判別します。*Import Strategy* を選択することもできます。

*Edit Import Strategy* をクリックします。

[.bordershadow]
image::nationalparks-import-strategy.png[width=500,link="self",window=_blank]

次の 3 つのオプションがあります。

* *Devfile* : link:{ocp4_starter_devfile_docs}[devfile,window='_blank'] 仕様を使用してアプリケーションスタックを作成します。リポジトリには、devfile 形式の `devfile.yaml` というファイルが含まれている必要があります。
* *Dockerfile* : ソース Git リポジトリ内の既存の Dockerfile からコンテナイメージを作成します。
* *Builder Image* : Source-to-Image と呼ばれるメカニズムを使用して、ソースコードから直接コンテナイメージを自動的に作成します。Dockerfile は必要ありません。

次のセクションで説明するように、ソースコードからコンテナイメージを作成するため、*Builder Image* を選択します。


[.bordershadow]
image::nationalparks-import-strategy-build.png[link="self",window=_blank]

TIP: リポジトリにはマルチステージのDockerfileが含まれているため、Dockerfileを使用することもできます。この演習の目的は、OpenShiftのBuilder Image機能を体験することです。

Builder Imageとして *Java* が選択されていることを確認し、OpenJDK 11を使用するためにバージョン *openjdk-11-ubi8* を選択してください。

*General* セクションまでスクロールダウンし、以下の項目を追加します。

*Application Name* :
[source,role=copypaste]
----
workshop
----

*Name* :
[source,role=copypaste]
----
nationalparks
----

*Build* セクションで *BuildConfig* を選択します。

*Deploy* セクションで *Deployment* を選択します。

*Advanced Options* で *Create a route* が *チェック* されていることを確認します。今度はこのビューから直接、別の *Secure Route* を作成します。

*Show advanced Routing options* をクリックします。すべてのオプションをデフォルトのままにして、*Security* セクションに移動します。*Secure Route* オプションにチェックを入れます。*TLS termination* で *Edge* を選択します。


[.bordershadow]
image::nationalparks-configure-service1.png[link="self",window=_blank]

[.bordershadow]
image::nationalparks-configure-service2.png[link="self",window=_blank]

下にスクロールして *Labels* セクションを展開し、3 つのラベルを追加します。

[.bordershadow]
image::nationalparks-configure-service4.png[link="self",window=_blank]

[.bordershadow]
image::nationalparks-configure-service3.png[link="self",window=_blank]

アプリケーション グループの名前:

[source,role=copypaste]
----
app=workshop
----

次に、このデプロイメントの名前:

[source,role=copypaste]
----
component=nationalparks
----

そして最後に、このコンポーネントがアプリケーション全体で果たす役割:

[source,role=copypaste]
----
role=backend
----

*Create* をクリックして送信します。

[#monitoring-the-build]
=== ビルドのモニタリング

ビルド ログを表示するには、Topology viewで `nationalparks` エントリをクリックし、*Resources* タブの *Builds* セクションで *View Logs* をクリックします。

[.bordershadow]
image::nationalparks-java-new-java-build.png[link="self",window=_blank]

アプリケーションの言語によってビルドプロセスは異なります。ただし、依存関係のダウンロードに時間がかかるため、最初のビルドには数分かかる場合があります。このプロセスはすべてリアルタイムで確認できます。

コマンドラインから、*Builds* も確認できます。

[.console-input]
[source,role="copypaste"]
----
oc get builds
----

次のような出力が表示されます。

[.console-output]
[source]
----
NAME              TYPE      FROM          STATUS     STARTED              DURATION
nationalparks-1   Source    Git@b052ae6   Running    About a minute ago   1m2s
----

次のコマンドでビルド ログを表示することもできます。

[.console-input]
[source,role="copypaste"]
----
oc logs -f builds/nationalparks-1
----

ビルドが正常に完了すると:

* S2Iプロセスは、生成されたイメージをOpenShift内部イメージレジストリにプッシュします。
* *Deployment* (D)はイメージが変更されたことを検出し、これにより
新しいデプロイメントが実行されます。
* この新しいデプロイメント用に *ReplicaSet* (RS)が生成されます。
* RSは実行中の *Pod* が存在しないことを検出し、デフォルトのレプリカ数が1であるため、1つのPodをデプロイします。

最後に、`oc get pods` コマンドを実行すると、ビルド Pod が終了（exited）し、アプリケーション *Pod* が準備完了(ready)かつ実行状態(running)にあることがわかります。

[.console-output]
[source]
----
NAME                        READY     STATUS      RESTARTS   AGE
nationalparks-1-tkid3       1/1       Running     3          2m
nationalparks-1-build       0/1       Completed   0          3m
parksmap-57df75c46d-xltcs   1/1       Running     0          2h
----

OpenShiftのWebコンソールをもう一度見てみましょう。アプリケーション作成時に有効にしたため、*Route* が作成されていることがわかります。URLはWebコンソール、またはコマンドラインで確認できます。

[.console-input]
[source,role="copypaste"]
----
oc get routes
----

次のような画面が表示されます。

[.console-output]
[source,role="copypaste",subs="attributes"]
----
NAME            HOST/PORT                                                   PATH      SERVICES        PORT       TERMINATION       WILDCARD
nationalparks   nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}      nationalparks   8080-tcp        edge 
parksmap        parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}           parksmap        8080-tcp        edge        none
----

上記の例では、URL は次のようになります。

[.console-output]
[source,subs="+attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

これはバックエンドアプリケーションなので、実際にはWebインターフェースはありません。
しかし、ブラウザで使用することはできます。parksmapフロントエンドと連携するすべてのバックエンドは、
`/ws/info/` エンドポイントを実装する必要があります。テストするには、ブラウザで次のURLにアクセスしてください。

link:https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/info/[National Parks Info Page,window='_blank']

WARNING: Podが実行中でアプリケーションが利用できない場合は、ヘルスチェックがまだ構成されていないため、数秒待ってページを更新してください。

シンプルな JSON 文字列が表示されます。

[source]
----
{"id":"nationalparks","displayName":"National Parks","center":{"latitude":"47.039304","longitude":"14.505178"},"zoom":4}
----

セクションの前半で、次のことを読みました。

_これはMongoDBデータベースに対して2D地理空間クエリを実行するアプリケーションです。_

しかし、まだデータベースがありません。

