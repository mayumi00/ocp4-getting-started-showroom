= 継続的インテグレーションとパイプライン
:navtitle: 継続的インテグレーションとパイプライン

include::vars.adoc[]

このセクションでは、パイプラインについて、そしてOpenShiftでパイプラインを構成してアプリケーションのライフサイクルを管理する方法について学習します。

継続的デリバリー（CD）パイプラインとは、ソフトウェアをバージョン管理からユーザーや顧客に届けるためのプロセスを自動化したものです。

ソフトウェアへのすべての変更（ソース管理にコミットされたもの）は、リリースに至るまで複雑なプロセスを経ます。このプロセスには、信頼性が高く繰り返し可能な方法でソフトウェアをビルドすること、そしてビルドされたソフトウェア（「ビルド」と呼ばれる）を複数のテスト段階とデプロイメント段階を経て進めることが含まれます。

OpenShift Pipelinesは、link:https://tekton.dev/[Tekton,window='_blank']を使用してパイプラインを構築するためのクラウドネイティブな継続的インテグレーションおよびデリバリー（CI/CD）ソリューションです。 Tekton は、基盤となる詳細を抽象化することで、複数のプラットフォーム (Kubernetes、サーバーレス、VM など) にわたるデプロイメントを自動化できる、柔軟な Kubernetes ネイティブのオープンソース CI/CD フレームワークです。

[.bordershadow]
image::devops-pipeline-flow.png[link="self",window=_blank]

[#understanding_tekton]
== Tektonの理解

Tekton は、パイプラインの概念を標準化し、CI/CD ソリューション全体で一貫した用語を提供するために、Kubernetes のlink:https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[Kubernetesカスタムリソース,window='_blank']をビルディングブロックとして定義しています。

パイプラインを定義するために必要なカスタムリソースは以下のとおりです。

* `Task` : 特定のタスク（例: コンテナイメージのビルド）を実行する、再利用可能な疎結合のステップ群
* `Pipeline` : パイプラインの定義と、パイプラインが実行する `Task`
* `TaskRun` : タスクインスタンスの実行結果
* `PipelineRun` : パイプラインインスタンスの実行結果（複数の `TaskRun` を含む）

[.bordershadow]
image::tekton-architecture.png[link="self",window=_blank]

つまり、パイプラインを作成するには、次の操作を行います。

* カスタムの `Tasks` を作成するか、ink:https://github.com/tektoncd/catalog[既存,window='_blank']の再利用可能な `Tasks` をインストールします。
* アプリケーションのデリバリーパイプラインを定義する `Pipeline` と `PipelineResources` を作成します。
* パイプライン実行用のボリューム/ファイルシステムを提供する `PersistentVolumeClaim` を作成するか、`PersistentVolumeClaim` を作成する `VolumeClaimTemplate` を提供します。
* パイプラインをインスタンス化して呼び出す `PipelineRun` を作成します。

パイプラインの概念の詳細については、パイプラインの定義に使用できるさまざまなパラメーターと属性を理解するための優れたガイドである link:https://tekton.dev/docs[Tektonのドキュメント,window='_blank']を参照してください。

[#create_your_pipeline]
== Exercise: パイプラインの作成

パイプラインはデリバリーサイクルの異なるステージ間でアプリケーションをプロモートする機能を提供するため、パイプラインを実行する継続的インテグレーションサーバーであるTektonを、継続的インテグレーションロールを持つプロジェクトにデプロイします。このプロジェクトで実行されるパイプラインには、デリバリーサイクルの異なるステージをモデル化するすべてのプロジェクトとやり取りする権限が付与されます。

それでは、Nationalparksバックエンド用のTektonパイプラインを作成しましょう。開発者パースペクティブで、左側のナビゲーションから *Pipelines -> Pipelines* をクリックし、*Create -> Pipeline* をクリックします。


[.bordershadow]
image::devops_create_pipeline.png[link="self",window=_blank]
 
ここでは、インタラクティブなパイプラインビルダーを確認できます。「タスクを追加」ボタンをクリックすると、パイプラインにタスクを追加できます。また、作成されたタスクをクリックして、パイプラインにパラメータを追加することもできます。ここでは時間を節約するために、*YAML view* を使用してパイプラインを作成します。

[.bordershadow]
image::devops_pipeline_builder_yaml.png[link="self",window=_blank]

ここで、使用している言語に応じて、適切なパイプラインを作成する必要があります。

====
*Java*

ここで、このTektonパイプラインをYAMLテキストエリアにコピーできます。このパイプラインは、ローカルGitサーバー（Gitea）からソースコードをクローンし、アプリケーションをビルドしてテストし、コンテナイメージをビルドしてOpenShiftにデプロイします。

[source,role="copypaste",subs="attributes"]
----
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: nationalparks-pipeline
spec:
  params:
    - default: nationalparks
      name: APP_NAME
      type: string
    - default: {ocp4_starter_gitea_url}/{ocp4_starter_gitea_user}/nationalparks.git
      description: The application git repository url
      name: APP_GIT_URL
      type: string
    - default: master
      description: The application git repository revision
      name: APP_GIT_REVISION
      type: string
  tasks:
    - name: git-clone
      params:
        - name: URL
          value: $(params.APP_GIT_URL)
        - name: REVISION
          value: $(params.APP_GIT_REVISION)
        - name: SUBMODULES
          value: 'true'
        - name: DEPTH
          value: '1'
        - name: SSL_VERIFY
          value: 'true'
        - name: DELETE_EXISTING
          value: 'true'
        - name: VERBOSE
          value: 'true'
      taskRef:
        kind: Task
        name: git-clone
      workspaces:
        - name: output
          workspace: app-source
    - name: build-and-test
      params:
        - name: MAVEN_IMAGE
          value: maven:3.8.3-openjdk-11
        - name: GOALS
          value:
            - package
        - name: PROXY_PROTOCOL
          value: http
      runAfter:
        - git-clone
      taskRef:
        kind: Task
        name: maven
      workspaces:
        - name: source
          workspace: app-source
        - name: maven_settings
          workspace: maven-settings
    - name: build-image
      params:
        - name: IMAGE
          value: image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest
        - name: BUILDER_IMAGE
          value: registry.redhat.io/rhel8/buildah:latest
        - name: STORAGE_DRIVER
          value: vfs
        - name: DOCKERFILE
          value: ./Dockerfile
        - name: CONTEXT
          value: .
        - name: TLSVERIFY
          value: 'true'
        - name: FORMAT
          value: oci
      runAfter:
        - build-and-test
      taskRef:
        kind: Task
        name: buildah
      workspaces:
        - name: source
          workspace: app-source
    - name: redeploy
      params:
        - name: SCRIPT
          value: oc rollout restart deployment/$(params.APP_NAME)
      runAfter:
        - build-image
      taskRef:
        kind: Task
        name: openshift-client
  workspaces:
    - name: app-source
    - name: maven-settings
----

それでは、*Pipeline builder* viewに戻って視覚的に確認してみましょう。

image::devops_pipeline_builder_java.png[link="self",window=_blank]

このパイプラインには 4 つのタスクが定義されています。

- *git clone* : これは、nationalparks のソースリポジトリをクローンし、`Workspace` `app-source` に保存する `Task` です。このワークスペースでは、作成された PVC `app-source-workspace` が使用されます。
- *build-and-test* : `maven` `Task` を使用して Java アプリケーションをビルドおよびテストします。
- *build-image* : これは、OpenShift への入力としてバイナリファイル（この場合は前のタスクで生成された JAR アーティファクト）を使用してイメージをビルドする link:https://buildah.io/[buildah,window=_blank] タスクです。
- *redeploy* : `openshift-client` タスクを使用して、前のラボで作成した `nationalparks` というデプロイメントを使用して、作成されたイメージを OpenShift にデプロイします。

image::devops_pipeline_tasks_java.png[link="self",window=_blank]

パイプラインはパラメトリックであり、デフォルト値が事前に設定されています。

2つの *Workspaces* を使用します。

- *app-source* : 次に作成する *PersistentVolumeClaim* `app-source-pvc` にリンクされます。これは、さまざまな *Task* で使用されるアーティファクトを保存するために使用します。
- *maven_settings* : Maven キャッシュ用の *EmptyDir* ボリューム。PVC で拡張することで、後続の Maven ビルドを高速化することもできます。

image::devops_pipeline_workspaces_java.png[link="self",window=_blank]

// *.NET*

// Here, we can copy this Tekton Pipeline in the YAML text area. This pipeline will clone the source code from GitHub, build and test the application, build a container image and deploy it on OpenShift.

// [.console-input]
// [source,bash,subs="+attributes,macros+"]
// ----
// apiVersion: tekton.dev/v1beta1
// kind: Pipeline
// metadata:
//   name: nationalparks-pipeline
// spec:
//   params:
//     - default: nationalparks
//       name: APP_NAME
//       type: string
//     - default: 'https://github.com/openshift-roadshow/nationalparks-dotnet.git'
//       description: The application git repository url
//       name: GIT_REPO
//       type: string
//     - default: master
//       name: GIT_REVISION
//       type: string
//     - default: 'image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest'
//       name: IMAGE_NAME
//       type: string
//     - default: .
//       name: PATH_CONTEXT
//       type: string
//     - default: '1'
//       name: MINOR_VERSION
//       type: string
//   resources: []
//   workspaces:
//     - name: workspace
//   tasks:
//     - name: fetch-repository
//       params:
//         - name: url
//           value: $(params.GIT_REPO)
//         - name: revision
//           value: $(params.GIT_REVISION)
//         - name: subdirectory
//           value: ''
//         - name: deleteExisting
//           value: 'true'
//       taskRef:
//         kind: ClusterTask
//         name: git-clone
//       workspaces:
//         - name: output
//           workspace: workspace
//     - name: deploy
//       params:
//         - name: SCRIPT
//           value: kubectl $@
//         - name: ARGS
//           value:
//             - rollout
//             - status
//             - deploy/$(params.APP_NAME)
//       runAfter:
//         - s2i-dotnet
//       taskRef:
//         kind: ClusterTask
//         name: openshift-client
//     - name: s2i-dotnet
//       runAfter:
//         - fetch-repository
//       taskRef:
//         kind: ClusterTask
//         name: s2i-dotnet
//       params:
//         - name: BUILDER_IMAGE
//           value: registry.redhat.io/rhel8/buildah
//         - name: VERSION
//           value: latest
//         - name: PATH_CONTEXT
//           value: .
//         - name: TLSVERIFY
//           value: 'true'
//         - name: IMAGE
//           value: >-
//             image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest
//         - name: SKIP_PUSH
//           value: 'false'
//         - name: ENV_VARS
//           value: []
//       workspaces:
//         - name: source
//           workspace: workspace
// ----

// Now, let's head back to the *Pipeline builder* view to see it visually.

// image::devops_pipeline_builder_dotnet.png[Pipeline Builder Java]

// This pipeline has 3 Tasks defined:

// - *fetch-repository*: this is a `ClusterTask` that will clone our source repository for nationalparks and store it to a `Workspace` `app-source` which will use the PVC created for it `app-source-workspace`
// - *build*: will build and test our .NET Core C# application, generate and push a container image automatically with compiled binaries inside OpenShift Container Registry
// - *deploy*: will deploy the created image on OpenShift using the Deployment named `nationalparks` we created in the previous lab

// image::devops_pipeline_tasks_dotnet.png[Pipeline Tasks Java]

// The Pipeline is parametric, with default values already preconfigured.

// It is using one *Workspace*:

// - *app-source*: this need to be linked to a *PersistentVolumeClaim* since will be used to store the code and the compiled binary to be used in different *Tasks*

// image::devops_pipeline_workspaces_dotnet.png[Pipeline Workspaces Java]

// *Javascript*

// Here, we can copy this Tekton Pipeline in the YAML text area. This pipeline will clone the source code from GitHub, build and test the application, build a container image and deploy it on OpenShift.

// [.console-input]
// [source,bash,subs="+attributes,macros+"]
// ----
// apiVersion: tekton.dev/v1beta1
// kind: Pipeline
// metadata:
//   name: nationalparks-pipeline
// spec:
//   params:
//     - default: nationalparks
//       name: APP_NAME
//       type: string
//     - default: 'https://github.com/openshift-roadshow/nationalparks-js.git'
//       description: The application git repository url
//       name: GIT_REPO
//       type: string
//     - default: master
//       name: GIT_REVISION
//       type: string
//     - default: 'image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest'
//       name: IMAGE_NAME
//       type: string
//     - default: .
//       name: PATH_CONTEXT
//       type: string
//     - default: '1'
//       name: MINOR_VERSION
//       type: string
//   tasks:
//     - name: fetch-repository
//       params:
//         - name: url
//           value: $(params.GIT_REPO)
//         - name: revision
//           value: $(params.GIT_REVISION)
//         - name: subdirectory
//           value: ''
//         - name: deleteExisting
//           value: 'true'
//       taskRef:
//         kind: ClusterTask
//         name: git-clone
//       workspaces:
//         - name: output
//           workspace: workspace
//     - name: build
//       params:
//         - name: IMAGE
//           value: $(params.IMAGE_NAME)
//         - name: TLSVERIFY
//           value: 'false'
//         - name: PATH_CONTEXT
//           value: $(params.PATH_CONTEXT)
//         - name: MINOR_VERSION
//           value: $(params.MINOR_VERSION)
//       runAfter:
//         - fetch-repository
//       taskRef:
//         kind: ClusterTask
//         name: s2i-nodejs
//       workspaces:
//         - name: source
//           workspace: workspace
//     - name: deploy
//       params:
//         - name: SCRIPT
//           value: kubectl $@
//         - name: ARGS
//           value:
//             - rollout
//             - status
//             - deploy/$(params.APP_NAME)
//       runAfter:
//         - build
//       taskRef:
//         kind: ClusterTask
//         name: openshift-client
//   workspaces:
//     - name: workspace
// ----

// A `Pipeline` is a user-defined model of a CD pipeline. A Pipeline’s code defines your entire build process, which typically includes stages for building an application, testing it and then delivering it.

// A `Task` in Tekton is a collection of one or more sequential steps, where each step is executed in its own container. Each step typically performs a single operation, such as compiling code, running tests, or building a container image. Tasks are highly reusable and can be parameterized to support different use cases.

// Now, let's head back to the *Pipeline builder* view to see it visually.

// image::devops_pipeline_builder_js.png[Pipeline Builder Java]

// This pipeline has 4 Tasks defined:

// - *fetch-repository*: this is a `ClusterTask` that will clone our source repository for nationalparks and store it to a `Workspace` `app-source` which will use the PVC created for it `app-source-workspace`
// - *build*: will build and test our NodeJS application, generate and push a container image automatically with compiled binaries inside OpenShift Container Registry
// - *deploy*: will deploy the created image on OpenShift using the Deployment named `nationalparks` we created in the previous lab

// image::devops_pipeline_tasks_js.png[Pipeline Tasks Java]

// The Pipeline is parametric, with default values already preconfigured.

// It is using one *Workspace*:

// - *app-source*: this need to be linked to a *PersistentVolumeClaim* since will be used to store the code and the compiled binary to be used in different *Tasks*

// image::devops_pipeline_workspaces_js.png[Pipeline Workspaces Java]

// *Python*

// Here, we can copy this Tekton Pipeline in the YAML text area. This pipeline will clone the source code from GitHub, build and test the application, build a container image and deploy it on OpenShift.

// [.console-input]
// [source,bash,subs="+attributes,macros+"]
// ----
// apiVersion: tekton.dev/v1beta1
// kind: Pipeline
// metadata:
//   name: nationalparks-pipeline
// spec:
//   params:
//     - default: nationalparks
//       name: APP_NAME
//       type: string
//     - default: 'https://github.com/openshift-roadshow/nationalparks-py.git'
//       description: The application git repository url
//       name: GIT_REPO
//       type: string
//     - default: master
//       name: GIT_REVISION
//       type: string
//     - default: 'image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest'
//       name: IMAGE_NAME
//       type: string
//     - default: .
//       name: PATH_CONTEXT
//       type: string
//     - default: '1'
//       name: MINOR_VERSION
//       type: string
//   tasks:
//     - name: fetch-repository
//       params:
//         - name: url
//           value: $(params.GIT_REPO)
//         - name: revision
//           value: $(params.GIT_REVISION)
//         - name: subdirectory
//           value: ''
//         - name: deleteExisting
//           value: 'true'
//       taskRef:
//         kind: ClusterTask
//         name: git-clone
//       workspaces:
//         - name: output
//           workspace: workspace
//     - name: build
//       params:
//         - name: IMAGE
//           value: $(params.IMAGE_NAME)
//         - name: TLSVERIFY
//           value: 'false'
//         - name: PATH_CONTEXT
//           value: $(params.PATH_CONTEXT)
//         - name: MINOR_VERSION
//           value: $(params.MINOR_VERSION)
//       runAfter:
//         - fetch-repository
//       taskRef:
//         kind: ClusterTask
//         name: s2i-python
//       workspaces:
//         - name: source
//           workspace: workspace
//     - name: deploy
//       params:
//         - name: SCRIPT
//           value: kubectl $@
//         - name: ARGS
//           value:
//             - rollout
//             - status
//             - deploy/$(params.APP_NAME)
//       runAfter:
//         - build
//       taskRef:
//         kind: ClusterTask
//         name: openshift-client
//   workspaces:
//     - name: workspace
// ----

// Now, let's head back to the *Pipeline builder* view to see it visually.

// image::devops_pipeline_builder_python.png[Pipeline Builder Java]

// This pipeline has 3 Tasks defined:

// - *fetch-repository*: this is a `ClusterTask` that will clone our source repository for nationalparks and store it to a `Workspace` `app-source` which will use the PVC created for it `app-source-workspace`
// - *build*: will build and test our Python application, generate and push a container image automatically with compiled binaries inside OpenShift Container Registry
// - *deploy*: it will deploy the created image on OpenShift using the Deployment named `nationalparks` we created in the previous lab

// image::devops_pipeline_tasks_python.png[Pipeline Tasks Java]

// The Pipeline is parametric, with default values already preconfigured.

// It is using one *Workspace*:

// - *app-source*: this need to be linked to a *PersistentVolumeClaim* since will be used to store the code and the compiled binary to be used in different *Tasks*

// image::devops_pipeline_workspaces_python.png[Pipeline Workspaces Java]
// --
====

最後に、*Create* ボタンをクリックしてパイプラインを作成してください。

[#add_storage_for_pipeline]
== 演習: パイプラインにストレージを追加する

OpenShift は、*Persistent Volume Claim* リクエストを通じて、アプリケーションを実行する Pod にアタッチされる link:https://kubernetes.io/docs/concepts/storage/persistent-volumes/[Persistent Volumes,window='_blank'] を使用してストレージを管理します。また、Web コンソールから簡単に管理できる機能も提供しています。
左側のメニューから、*Storage* -> *Persistent Volume Claims* に移動します。

右上の *Create Persistent Volume Claim* ボタンをクリックします。


[.bordershadow]
image::nationalparks-codechanges-pipeline-pvc-1.png[link="self",window=_blank]

*Persistent Volume Claim name* に *app-source-pvc* を入力します。

*Size* セクションには *1* を入力します。これは、パイプライン用に RWO シングルユーザーアクセスモードを使用して 1 GiB の永続ボリュームを作成するためです。

その他の設定はすべてデフォルトのままにして、*Create* をクリックします。

[.bordershadow]
image::nationalparks-codechanges-pipeline-pvc.png[link="self",window=_blank]

TIP: *Storage Class* は、クラスターで使用可能なストレージのタイプです。

[#run_the_pipeline]
== パイプラインの実行

これで、Webコンソールからパイプラインを開始できます。左側のメニューで *Pipelines -> Pipelines* をクリックし、*nationalparks-pipeline* をクリックします。右上の *Actions* リストから *Start* をクリックします。


[.bordershadow]
image::devops-pipeline-start-1.png[link="self",window=_blank]

パイプラインを追加するためのパラメータの入力を求められます。デフォルト値が表示されます。適切な値は既に設定済みです。

*Workspaces* -> *app-source* で、リストから *PersistentVolumeClaim* を選択し、次に *app-source-pvc* を選択します。これは、パイプライン内のパイプラインタスクによって使用される共有ボリュームで、ソースコードとコンパイル済みアーティファクトが格納されます。

*Workspaces* -> *maven-settings* では、*Empty Directory* のままにしておきます。


[.bordershadow]

パイプラインを実行するには、*Start* をクリックします。

[.bordershadow]
image::devops-pipeline-start-2.png[link="self",window=_blank]

パイプラインの実行はWebコンソールから簡単に確認できます。左側のメニューで *Pipelines -> Pipeline* をクリックし、*nationalparks-pipeline* をクリックします。*Pipeline Runs* タブに切り替えて、進行中のすべてのステップを確認してください。

[.bordershadow]
image::devops-pipeline-run-1.png[link="self",window=_blank]

`PipelineRun` をクリックします。

[.bordershadow]
image::devops-pipeline-run-java-2.png[link="self",window=_blank]

次に、実行中の *Task* をクリックしてログを確認します。

[.bordershadow]
image::devops-pipeline-run-java-3.png[link="self",window=_blank]

PipelineRun が正常に完了したことを確認します。

[.bordershadow]
image::devops-pipeline-run-java-4.png[link="self",window=_blank]
